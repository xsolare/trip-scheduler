class i{static async load(t){return console.warn(`[WEB-STUB] Database.load called for ${t}, but this is a web build. Returning a mock.`),new i}async select(t,e){return console.warn("[WEB-STUB] DB.select called. Not available in web build."),Promise.resolve([])}async execute(t,e){return console.warn("[WEB-STUB] DB.execute called. Not available in web build."),Promise.resolve({rowsAffected:0,lastInsertId:0})}}let r=null;async function n(){if(r)return r;try{return r=await i.load("sqlite:trip-scheduler.db"),console.log("Database connected successfully"),r}catch(a){throw console.error("Failed to load database:",a),a}}class c{constructor(t){this.db=t}async getByTripId(t){return(await this.db.select("SELECT * FROM days WHERE trip_id = $1 ORDER BY date ASC",[t])).map(s=>({...s,activities:JSON.parse(s.activities||"[]")}))}}class l{constructor(t){this.db=t}async getAll(){return(await this.db.select("SELECT * FROM trips ORDER BY start_date DESC")).map(e=>({...e,cities:JSON.parse(e.cities||"[]"),participants:JSON.parse(e.participants||"[]"),tags:JSON.parse(e.tags||"[]")}))}async getById(t){const e=await this.db.select("SELECT * FROM trips WHERE id = $1",[t]);if(e.length===0)return null;const s=e[0];return{...s,cities:JSON.parse(s.cities||"[]"),participants:JSON.parse(s.participants||"[]"),tags:JSON.parse(s.tags||"[]")}}}class o{db;trips;days;async initDb(){return this.db=await n(),this.trips=new l(this.db),this.days=new c(this.db),this}async getUnsyncedChanges(){return this.db.select("SELECT * FROM sync_log WHERE synced = 0 ORDER BY timestamp ASC")||[]}async markAsSynced(t){if(t.length===0)return;const e=t.map(()=>"?").join(",");await this.db.execute(`UPDATE sync_log SET synced = 1 WHERE id IN (${e})`,t)}async testConnection(){try{return await this.db.select("SELECT 1"),!0}catch(t){return console.error("Database connection failed:",t),!1}}}export{o as RealDatabaseClient};
