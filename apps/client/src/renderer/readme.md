# Архитектура клиентского приложения "Trip Scheduler"

## Введение

Данный документ описывает архитектуру клиентского приложения "Trip Scheduler", построенного на принципах **Vertical Slice Architecture (VSA)**. Этот подход нацелен на создание масштабируемых, поддерживаемых и легко расширяемых фронтенд-приложений.

Ключевая идея архитектуры заключается в **организации кодовой базы вокруг функциональных срезов (фич), а не по техническим типам файлов**. Каждый "слайс" представляет собой самодостаточный вертикальный разрез приложения, проходящий через все слои — от UI-компонентов до логики управления состоянием.

Ограничение "один поток" интерпретируется как **строгий однонаправленный поток зависимостей**: вышележащие слои могут зависеть только от нижележащих. Это предотвращает циклические зависимости, упрощает рефакторинг и делает архитектуру предсказуемой и прозрачной.

## Ключевые принципы

1.  **Слоевая структура (Layered Architecture)**: Код разделен на слои с четко определенными зонами ответственности. Зависимости между слоями строго контролируются.
2.  **Вертикальные срезы (Vertical Slices)**: Функциональность группируется по фичам. Весь код, относящийся к одной фиче (UI, состояние, модели), находится в одной директории, что обеспечивает **высокую связность (High Cohesion)**.
3.  **Низкая связанность (Low Coupling)**: Фичи максимально изолированы друг от друга, что позволяет разрабатывать и модифицировать их независимо, минимизируя побочные эффекты.
4.  **Однонаправленный поток зависимостей**: Зависимости разрешены только в одном направлении — от верхних слоев к нижним. Это правило обеспечивается числовыми префиксами в директории `components`.

## Структура проекта

### Директория `components` — Ядро архитектуры

Это центральная директория, реализующая слоевую модель. Числовой префикс каждой поддиректории определяет её уровень в иерархии и правила импорта.

#### `01.kit` — UI Kit

- **Назначение**: Самый низкий уровень, содержащий атомарные и переиспользуемые UI-компоненты без бизнес-логики. Это строительные блоки для всего интерфейса.
- **Примеры**: `kit-btn`, `kit-input`, `kit-avatar`, `kit-calendar`, `kit-dialog-with-close`, `kit-skeleton`.
- **Правило**: Компоненты этого слоя не могут импортировать ничего из слоев `02` и выше.

#### `02.shared` — Общие компоненты (Виджеты)

- **Назначение**: Более сложные, но всё ещё универсальные компоненты, используемые в разных частях приложения. Они могут состоять из компонентов `01.kit`.
- **Примеры**: `app-header`, `app-footer`, `async-state-wrapper`, `confirm-dialog-manager`, `theme-manager`, `profile-drawer`.
- **Правило**: Могут импортировать только из `01.kit`.

#### `03.domain` — Доменные сущности

- **Назначение**: Инкапсулирует сложную бизнес-логику, тесно связанную с конкретной предметной областью. В проекте этот слой представлен сущностью `plan-geolocation-section`, которая полностью управляет логикой карт и геолокации.
- **Примеры**: `trip-info/plan-geolocation-section` со своими `composables` (например, `use-geolocation-map`, `use-geolocation-drawing`), моделями и UI.
- **Правило**: Могут импортировать из `01.kit` и `02.shared`.

#### `04.features` — Функциональные блоки (Фичи)

- **Назначение**: Реализация "вертикальных срезов". Каждая директория здесь — это конкретный пользовательский сценарий или бизнес-функция. Фичи инкапсулируют собственное состояние (store), UI и модели.
- **Структура**: Фичи сгруппированы по контексту. Например, `trip-info` содержит фичи, относящиеся к странице путешествия.
- **Примеры**:
  - `trip-info/trip-comments`: Комментарии к путешествию.
  - `trip-info/trip-memories`: Воспоминания (фото и заметки).
  - `trip-info/trip-plan`: План путешествия по активностям.
  - `trip-info/trip-sections`: Дополнительные секции, такие как `booking-section`, `checklist-section`, `finances-section`.
- **Правило**: Могут импортировать из `01.kit`, `02.shared`, `03.domain`. Фичи не должны напрямую зависеть друг от друга.

#### `05.modules` — Модули приложения (Страницы и крупные блоки)

- **Назначение**: Композиционный слой, который объединяет фичи и виджеты для создания полноценных частей интерфейса, таких как страницы или сложные составные блоки.
- **Примеры**: `trips-hub` (список всех путешествий), `trip-info` (детальная страница путешествия), `account` (набор страниц управления аккаунтом: `profile`, `quota`, `settings`).
- **Правило**: Могут импортировать все нижележащие слои (`01` - `04`).

#### `06.layouts` — Слои представления (Шаблоны)

- **Назначение**: Определяет общую структуру страниц приложения.
- **Примеры**: `default` (стандартный шаблон с хедером и футером), `empty` (для страниц авторизации), `trip-info` (специализированный шаблон для страницы путешествия).
- **Правило**: Могут использовать все нижележащие слои.

### Другие ключевые директории

- **`assets`**: Глобальные стили, миксины, переменные и темы оформления.
- **`pages`**: Точки входа для роутинга. Файлы здесь соответствуют URL-адресам и, как правило, просто импортируют и отображают компонент из слоя `05.modules`.
- **`plugins`**: Плагины Vue для инициализации глобальной логики:
  - `request`: Управляет состоянием API-запросов (загрузка, ошибки).
  - `session-restore`: Восстанавливает сессию пользователя при запуске.
  - `theme`: Применяет выбранную тему и обновляет мета-теги.
- **`service-worker`**: Логика PWA для работы в оффлайн-режиме и кеширования.
- **`shared`**: Глобально переиспользуемый код, не являющийся Vue-компонентами.
  - `composables`: Общие `use`-функции (`useConfirm`, `useToast`).
  - `services`: Сервисы для взаимодействия с внешним миром. Особенно важен `database`, который абстрагирует работу с API через разные клиенты (`trpc`, `sql`, `mock`) и репозитории для каждой сущности.
  - `store`: Глобальные хранилища Pinia (`auth.store`, `theme.store`, `toast.store`).
  - `types`: Глобальные типы и модели данных.

## Поток данных и управление состоянием

1.  **Взаимодействие с API**:
    - Вся работа с API инкапсулирована в `shared/services/database`. Гибкая система "клиентов" (`trpc`, `sql`, `mock`) позволяет приложению работать в разных средах (веб, десктоп, демо-режим).
    - Плагин `plugins/request` централизованно управляет состоянием асинхронных операций (загрузка, ошибки, отмена), предоставляя хуки `useRequest` и `useRequestStatus`.

2.  **Управление состоянием (Pinia)**:
    - **Глобальное состояние** (`shared/store`): Данные, необходимые всему приложению (аутентификация, тема, диалоговые окна).
    - **Состояние фичи** (`components/04.features/.../store`): Каждая фича имеет собственное хранилище (`trip-comments.store`, `trip-memories.store`), что обеспечивает её независимость.
    - **Состояние модуля** (`components/05.modules/trip-info/store`): Сложные модули, такие как `trip-info`, могут иметь свои хранилища для управления UI-логикой, объединяющей несколько фич.

3.  **Поток данных**: Пользователь взаимодействует с UI-компонентами (`04.features`, `05.modules`). Это взаимодействие вызывает экшены в соответствующем хранилище Pinia. Экшен, в свою очередь, обращается к сервисному слою (`shared/services`) для получения или отправки данных. После получения ответа состояние в хранилище обновляется, что реактивно вызывает перерисовку UI.

**Сильные стороны**:

- **Масштабируемость**: Легко добавлять новые фичи, не затрагивая существующие. Новая функциональность создается в новой папке в `04.features`.
- **Поддерживаемость**: Четкая структура и строгие правила зависимостей упрощают навигацию по коду, отладку и рефакторинг.
- **Низкая связанность (Low Coupling)**: Фичи и модули изолированы, что снижает риск каскадных изменений.
- **Высокая связность (High Cohesion)**: Весь код, относящийся к одной фиче, сгруппирован в одном месте, что упрощает его понимание и доработку.
- **Адаптивность**: Абстракция API через клиенты (`trpc`, `sql`, `mock`) позволяет легко переключать источники данных и запускать приложение в разных окружениях.
- **Параллельная разработка**: Разные разработчики могут эффективно работать над разными срезами одновременно, не создавая конфликтов.
